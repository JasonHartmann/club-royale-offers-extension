diff --git a/features/backToBackTool.js b/features/backToBackTool.js
index 3546457..552e30d 100644
--- a/features/backToBackTool.js
+++ b/features/backToBackTool.js
@@ -96,6 +96,36 @@
         return null;
     }

+    function extractDisembarkPortFromItinerary(itineraryRecord) {
+        if (!itineraryRecord || !Array.isArray(itineraryRecord.days) || itineraryRecord.days.length === 0) {
+            return '';
+        }
+
+        // First, try to find a port with activity "DEBARK" (one-way sailings end with disembark)
+        for (let i = itineraryRecord.days.length - 1; i >= 0; i--) {
+            const day = itineraryRecord.days[i];
+            if (day && Array.isArray(day.ports) && day.ports.length > 0) {
+                const port = day.ports[0];
+                if (port && port.port && port.activity === 'DEBARK') {
+                    return normalizePortName(port.port.name || port.port.code || '');
+                }
+            }
+        }
+
+        // If no DEBARK found, get the last actual port (not cruising, not embark)
+        for (let i = itineraryRecord.days.length - 1; i >= 0; i--) {
+            const day = itineraryRecord.days[i];
+            if (day && day.type !== 'CRUISING' && Array.isArray(day.ports) && day.ports.length > 0) {
+                const port = day.ports[0];
+                if (port && port.port && port.port.name && port.port.name.toLowerCase() !== 'cruising') {
+                    return normalizePortName(port.port.name || port.port.code || '');
+                }
+            }
+        }
+
+        return '';
+    }
+
     function parseNights(entry, itineraryRecord) {
         const sailing = entry && entry.sailing ? entry.sailing : {};
         const sources = [sailing.totalNights, sailing.sailingNights, sailing.lengthOfStay, itineraryRecord && itineraryRecord.totalNights];
@@ -187,15 +217,24 @@
                 task();
                 return;
             }
+            const minVisibleMs = 140;
+            const now = () => (typeof performance !== 'undefined' && performance && typeof performance.now === 'function') ? performance.now() : Date.now();
+            const start = now();
             try { spinner.showSpinner(); } catch (e) {}
+            const hide = () => {
+                try { spinner.hideSpinner(); } catch (e) {}
+            };
             const run = () => {
                 try {
                     task();
                 } finally {
-                    try { spinner.hideSpinner(); } catch (e) {}
+                    const elapsed = now() - start;
+                    const remaining = Math.max(0, minVisibleMs - elapsed);
+                    setTimeout(hide, remaining);
                 }
             };
-            setTimeout(run, 0);
+            // Let the browser paint the spinner before running the task.
+            requestAnimationFrame(() => setTimeout(run, 0));
         },

         registerEnvironment(opts) {
@@ -234,7 +273,7 @@
                         });
                     } catch(e) { /* fall back to original rows on error */ }
                     const afterCount = Array.isArray(filtered) ? filtered.length : 0;
-                    if (window && window.GOBO_DEBUG_ENABLED) {
+                    if (window && window.GOBO_DEBUG_LOGS) {
                         try {
                             const removed = beforeCount - afterCount;
                             const sampleRemoved = [];
@@ -312,7 +351,7 @@
         // Debugging helper: capture-phase listener to detect clicks that never reach our handlers
         _installGlobalDebugCapture() {
             try {
-                if (typeof window === 'undefined' || !window.GOBO_DEBUG_ENABLED) return;
+                if (typeof window === 'undefined' || !window.GOBO_DEBUG_LOGS) return;
                 if (this._debugCaptureInstalled) return;
                 const dbg = (ev) => {
                     try {
@@ -522,7 +561,7 @@
                         let longest = null;
                         try {
                             // Avoid heavy diagnostics for very large row sets unless debugging explicitly enabled
-                            const doHeavyDiag = (typeof window !== 'undefined' && window.GOBO_DEBUG_ENABLED) || (Array.isArray(rows) && rows.length <= 500);
+                            const doHeavyDiag = (typeof window !== 'undefined' && window.GOBO_DEBUG_LOGS) || (Array.isArray(rows) && rows.length <= 500);
                             // The B2B tool always computes diagnostics regardless of any table-level autorun flag.
                             const autoRunB2B = true;
                             if (typeof window !== 'undefined' && window.B2BUtils && typeof window.B2BUtils.computeB2BDepth === 'function') {
@@ -559,7 +598,8 @@
                 allowSideBySide: !!this._context.allowSideBySide,
                 bannerTimeout: null,
                 ui: null,
-                keyHandler: null
+                keyHandler: null,
+                priceSelections: {}
             };
             this._renderOverlay();
         },
@@ -801,12 +841,28 @@
                 (entry.sailing && entry.sailing.departurePort && entry.sailing.departurePort.name)
                 || (itineraryRecord && itineraryRecord.departurePortName)
             );
+            const departureRegion = normalizePortName(
+                (entry.sailing && entry.sailing.departurePort && entry.sailing.departurePort.region)
+                || (itineraryRecord && itineraryRecord.departurePortRegion)
+                || (entry.sailing && entry.sailing.region)
+                || (entry.sailing && entry.sailing.destination && entry.sailing.destination.name)
+            );
             const arrivalPort = normalizePortName(
                 (entry.sailing && entry.sailing.arrivalPort && entry.sailing.arrivalPort.name)
                 || (entry.sailing && entry.sailing.returnPort && entry.sailing.returnPort.name)
                 || (itineraryRecord && (itineraryRecord.arrivalPortName || itineraryRecord.returnPortName))
+                // For one-way sailings without explicit arrival/return ports, extract from itinerary days
+                || (itineraryRecord && extractDisembarkPortFromItinerary(itineraryRecord))
                 || departurePort
             );
+            const arrivalRegion = normalizePortName(
+                (entry.sailing && entry.sailing.arrivalPort && entry.sailing.arrivalPort.region)
+                || (entry.sailing && entry.sailing.returnPort && entry.sailing.returnPort.region)
+                || (itineraryRecord && (itineraryRecord.arrivalPortRegion || itineraryRecord.returnPortRegion))
+                || (entry.sailing && entry.sailing.region)
+                || (entry.sailing && entry.sailing.destination && entry.sailing.destination.name)
+                || departureRegion
+            );
             const destinationLabel = normalizePortName(
                 (entry.sailing && entry.sailing.destinationPort && entry.sailing.destinationPort.name)
                 || (entry.sailing && entry.sailing.destination && entry.sailing.destination.name)
@@ -826,6 +882,8 @@
                 nights,
                 embarkPort: departurePort,
                 disembarkPort: arrivalPort,
+                embarkRegion: departureRegion,
+                disembarkRegion: arrivalRegion,
                 destinationLabel,
                 itineraryName: (entry.sailing && entry.sailing.itineraryDescription) || (itineraryRecord && itineraryRecord.itineraryDescription) || '',
                 timeline,
@@ -838,6 +896,218 @@
             return meta;
         },

+        _resolveRegion(meta) {
+            if (!meta) return '';
+            const fromMeta = (meta.disembarkRegion || meta.embarkRegion || '').toString().trim();
+            if (fromMeta) return fromMeta;
+            const timeline = Array.isArray(meta.timeline) ? meta.timeline : [];
+            const timelineRegion = timeline
+                .map(item => {
+                    const label = item && item.label ? String(item.label) : '';
+                    const parts = label.split(',');
+                    return (parts[1] || '').trim();
+                })
+                .find(Boolean);
+            return timelineRegion || '';
+        },
+
+        _getDefaultPriceCategory(meta) {
+            const label = meta && meta.roomLabel ? String(meta.roomLabel).trim() : '';
+            let category = '';
+            try {
+                if (typeof RoomCategoryUtils !== 'undefined' && RoomCategoryUtils && typeof RoomCategoryUtils.classifyBroad === 'function') {
+                    category = RoomCategoryUtils.classifyBroad(label) || '';
+                } else if (typeof window !== 'undefined' && window.RoomCategoryUtils && typeof window.RoomCategoryUtils.classifyBroad === 'function') {
+                    category = window.RoomCategoryUtils.classifyBroad(label) || '';
+                }
+            } catch (e) { category = ''; }
+            switch ((category || '').toUpperCase()) {
+                case 'SUITE':
+                    return 'suiteUpgrade';
+                case 'BALCONY':
+                    return 'balconyUpgrade';
+                case 'OUTSIDE':
+                    return 'oceanViewUpgrade';
+                default:
+                    return 'interior';
+            }
+        },
+
+        _getSelectedPriceCategory(rowId, meta) {
+            if (!this._activeSession) return 'interior';
+            if (!this._activeSession.priceSelections) this._activeSession.priceSelections = {};
+            if (!this._activeSession.priceSelections[rowId]) {
+                this._activeSession.priceSelections[rowId] = this._getDefaultPriceCategory(meta);
+            }
+            return this._activeSession.priceSelections[rowId];
+        },
+
+        _setSelectedPriceCategory(rowId, key) {
+            if (!this._activeSession) return;
+            if (!this._activeSession.priceSelections) this._activeSession.priceSelections = {};
+            this._activeSession.priceSelections[rowId] = key;
+        },
+
+        _getPricingData(meta) {
+            const entry = meta && meta.entry ? meta.entry : null;
+            const offer = entry && entry.offer ? entry.offer : null;
+            const sailing = entry && entry.sailing ? entry.sailing : null;
+            const state = (typeof App !== 'undefined' && App && App.TableRenderer) ? App.TableRenderer.lastState : null;
+            const includeTaxes = (typeof App !== 'undefined' && App && App.Utils && typeof App.Utils.getIncludeTaxesAndFeesPreference === 'function')
+                ? App.Utils.getIncludeTaxesAndFeesPreference(state)
+                : true;
+            const utils = (typeof App !== 'undefined' && App && App.Utils) ? App.Utils : (typeof Utils !== 'undefined' ? Utils : null);
+            const interiorRaw = utils && typeof utils.computeInteriorYouPayPrice === 'function'
+                ? utils.computeInteriorYouPayPrice(offer, sailing, { includeTaxes, state, entry })
+                : null;
+            const fallbackRaw = utils && typeof utils.computeOfferValue === 'function' ? utils.computeOfferValue(offer, sailing) : null;
+            const valueRaw = (interiorRaw != null && isFinite(interiorRaw)) ? interiorRaw : fallbackRaw;
+            const valueFmt = utils && typeof utils.formatOfferValue === 'function' ? utils.formatOfferValue(valueRaw) : '-';
+            const formatUpgrade = (columnKey) => {
+                if (!utils || typeof utils.formatUpgradePriceForColumn !== 'function') return '-';
+                return utils.formatUpgradePriceForColumn(columnKey, offer, sailing, { includeTaxes, state });
+            };
+            const rawUpgrade = (columnKey) => {
+                if (!utils || typeof utils.computeUpgradePriceForColumn !== 'function') return null;
+                return utils.computeUpgradePriceForColumn(columnKey, offer, sailing, { includeTaxes, state });
+            };
+            let taxesValue = null;
+            let taxesIncluded = null;
+            try {
+                if (sailing) {
+                    const shipCode = (sailing.shipCode || '').toString().trim();
+                    const sailDate = (sailing.sailDate || '').toString().trim().slice(0, 10);
+                    const key = shipCode && sailDate ? `SD_${shipCode}_${sailDate}` : null;
+                    const cache = (typeof ItineraryCache !== 'undefined' && ItineraryCache && typeof ItineraryCache.get === 'function')
+                        ? ItineraryCache
+                        : (typeof App !== 'undefined' && App && App.ItineraryCache ? App.ItineraryCache : null);
+                    const entryCache = key && cache && typeof cache.get === 'function' ? cache.get(key) : null;
+                    let rawTaxes = entryCache && entryCache.taxesAndFees != null ? entryCache.taxesAndFees : (sailing.taxesAndFees != null ? sailing.taxesAndFees : null);
+                    if (rawTaxes && typeof rawTaxes === 'object' && typeof rawTaxes.value === 'number') rawTaxes = rawTaxes.value;
+                    if (typeof rawTaxes === 'string') {
+                        const cleaned = rawTaxes.replace(/[^0-9.\-]/g, '');
+                        rawTaxes = cleaned ? Number(cleaned) : null;
+                    }
+                    if (typeof rawTaxes === 'number' && isFinite(rawTaxes)) {
+                        const multiplier = sailing.isGOBO ? 1 : 2;
+                        taxesValue = rawTaxes * multiplier;
+                    }
+                    taxesIncluded = entryCache && typeof entryCache.taxesAndFeesIncluded === 'boolean'
+                        ? entryCache.taxesAndFeesIncluded
+                        : (typeof sailing.taxesAndFeesIncluded === 'boolean' ? sailing.taxesAndFeesIncluded : null);
+                }
+            } catch (e) { /* ignore */ }
+            const taxesLabel = includeTaxes ? 'Included' : 'Excluded';
+            const taxesText = taxesValue != null && utils && typeof utils.formatOfferValue === 'function'
+                ? `Taxes & Fees: ${utils.formatOfferValue(taxesValue)}${taxesLabel ? ` (${taxesLabel})` : ''}`
+                : `Taxes & Fees: --${taxesLabel ? ` (${taxesLabel})` : ''}`;
+            return {
+                valuesRaw: {
+                    interior: valueRaw,
+                    oceanViewUpgrade: rawUpgrade('oceanViewUpgrade'),
+                    balconyUpgrade: rawUpgrade('balconyUpgrade'),
+                    suiteUpgrade: rawUpgrade('suiteUpgrade')
+                },
+                valuesFmt: {
+                    interior: valueFmt,
+                    oceanViewUpgrade: formatUpgrade('oceanViewUpgrade'),
+                    balconyUpgrade: formatUpgrade('balconyUpgrade'),
+                    suiteUpgrade: formatUpgrade('suiteUpgrade')
+                },
+                taxesText
+            };
+        },
+
+        _computeChainTotal() {
+            if (!this._activeSession) return { total: null, hasAny: false };
+            let total = 0;
+            let hasAny = false;
+            this._activeSession.chain.forEach(rowId => {
+                const meta = this._getMeta(rowId);
+                if (!meta) return;
+                const pricing = this._getPricingData(meta);
+                const key = this._getSelectedPriceCategory(rowId, meta);
+                const raw = pricing && pricing.valuesRaw ? pricing.valuesRaw[key] : null;
+                if (typeof raw === 'number' && isFinite(raw)) {
+                    total += raw;
+                    hasAny = true;
+                }
+            });
+            return { total, hasAny };
+        },
+
+        _buildPricingSection(meta, rowId, options) {
+            const opts = options || {};
+            const pricing = this._getPricingData(meta);
+            const wrapper = document.createElement('div');
+            wrapper.className = 'b2b-pricing';
+            const grid = document.createElement('div');
+            grid.className = 'b2b-pricing-grid';
+            const items = [
+                { key: 'interior', label: 'Interior' },
+                { key: 'oceanViewUpgrade', label: 'Oceanview' },
+                { key: 'balconyUpgrade', label: 'Balcony' },
+                { key: 'suiteUpgrade', label: 'Suite' }
+            ];
+            const selectedKey = opts.selectable ? this._getSelectedPriceCategory(rowId, meta) : null;
+            const useButton = opts.selectable && opts.useButton !== false;
+            items.forEach(item => {
+                const chip = document.createElement(useButton ? 'button' : 'div');
+                chip.className = 'b2b-price-chip' + (selectedKey === item.key ? ' selected' : '');
+                if (opts.selectable) {
+                    chip.classList.add('is-clickable');
+                    if (useButton) {
+                        chip.type = 'button';
+                    } else {
+                        chip.setAttribute('role', 'button');
+                        chip.setAttribute('tabindex', '0');
+                    }
+                    const handleSelect = (ev) => {
+                        ev.preventDefault();
+                        this._setSelectedPriceCategory(rowId, item.key);
+                        if (typeof opts.onSelectCategory === 'function') {
+                            opts.onSelectCategory(item.key);
+                        } else {
+                            this._renderChain();
+                        }
+                    };
+                    chip.addEventListener('click', handleSelect);
+                    if (!useButton) {
+                        chip.addEventListener('mousedown', (ev) => {
+                            // Prevent focus-induced scroll jumps on some browsers
+                            ev.preventDefault();
+                        });
+                    }
+                    chip.addEventListener('keydown', (ev) => {
+                        if (ev.key === 'Enter' || ev.key === ' ') {
+                            handleSelect(ev);
+                        }
+                    });
+                }
+                const label = document.createElement('span');
+                label.className = 'b2b-price-label';
+                label.textContent = item.label;
+                const value = document.createElement('span');
+                value.className = 'b2b-price-value';
+                const rawVal = pricing && pricing.valuesRaw ? pricing.valuesRaw[item.key] : null;
+                if (rawVal == null || !isFinite(rawVal)) {
+                    value.textContent = 'Sold Out';
+                    chip.classList.add('is-sold-out');
+                } else {
+                    value.textContent = (pricing && pricing.valuesFmt && pricing.valuesFmt[item.key]) ? pricing.valuesFmt[item.key] : '-';
+                }
+                chip.appendChild(label);
+                chip.appendChild(value);
+                grid.appendChild(chip);
+            });
+            wrapper.appendChild(grid);
+            const taxes = document.createElement('div');
+            taxes.className = 'b2b-tax-line';
+            taxes.textContent = pricing && pricing.taxesText ? pricing.taxesText : 'Taxes & Fees: --';
+            wrapper.appendChild(taxes);
+            return wrapper;
+        },
+
         _formatRoute(meta) {
             if (!meta) return 'Route TBA';
             const origin = normalizePortName(meta.embarkPort) || 'Embark TBA';
@@ -850,12 +1120,29 @@
         _renderChain() {
             if (!this._activeSession || !this._activeSession.ui) return;
             const container = this._activeSession.ui.chainCards;
+            const previousScrollTop = container ? container.scrollTop : 0;
+            const previousScrollHeight = container ? container.scrollHeight : 0;
             container.innerHTML = '';
             this._activeSession.chain.forEach((rowId, idx) => {
                 const meta = this._getMeta(rowId);
                 if (!meta) return;
                 const card = document.createElement('div');
-                card.className = 'b2b-chain-card' + (idx === 0 ? ' is-root' : '');
+                let cardClass = 'b2b-chain-card';
+                if (idx === 0) {
+                    cardClass += ' is-root';
+                } else {
+                    // Apply card type styling based on stored type
+                    const chainTypes = this._activeSession.chainTypes || {};
+                    const cardType = chainTypes[rowId];
+                    if (cardType === 'region-link') {
+                        cardClass += ' b2b-chain-region-link';
+                    } else if (cardType === 'side-by-side') {
+                        cardClass += ' b2b-chain-side-by-side';
+                    } else if (cardType === 'same-ship') {
+                        cardClass += ' b2b-chain-same-ship';
+                    }
+                }
+                card.className = cardClass;
                 card.dataset.rowId = rowId;
                 const head = document.createElement('div');
                 head.className = 'b2b-chain-step-head';
@@ -879,6 +1166,11 @@
                 `;
                 card.appendChild(metaBlock);

+                try {
+                    const pricing = this._buildPricingSection(meta, rowId, { selectable: true, useButton: false });
+                    card.appendChild(pricing);
+                } catch(e) { /* ignore pricing build errors */ }
+
                 if (meta.timeline && meta.timeline.length) {
                     const table = document.createElement('table');
                     table.className = 'b2b-timeline-table';
@@ -921,8 +1213,22 @@
             this._activeSession.ui.saveBtn.disabled = !canSave;
             this._activeSession.ui.resetBtn.disabled = this._activeSession.chain.length <= 1;
             this._setStatusText();
-            // Ensure the selected sailings viewport scrolls to show the most recently added sailing
-            try { this._scrollChainToBottom(); } catch (e) { /* ignore scroll errors */ }
+            const lastChainSize = this._activeSession._lastChainSize || 0;
+            const chainSize = this._activeSession.chain.length;
+            this._activeSession._lastChainSize = chainSize;
+            const didAutoScroll = chainSize > lastChainSize;
+            if (didAutoScroll) {
+                try { this._scrollChainToBottom(); } catch (e) { /* ignore scroll errors */ }
+            }
+            // Preserve scroll position when only updating pricing selections
+            try {
+                if (container && !didAutoScroll) {
+                    const newScrollHeight = container.scrollHeight || 0;
+                    const delta = newScrollHeight - previousScrollHeight;
+                    const nextScrollTop = previousScrollTop + (delta > 0 ? 0 : 0);
+                    container.scrollTop = Math.max(0, nextScrollTop);
+                }
+            } catch (e) { /* ignore scroll errors */ }
             try {
                 if (this._activeSession && this._activeSession.ui && typeof this._activeSession.ui._runScrollbarDetection === 'function') {
                     this._activeSession.ui._runScrollbarDetection();
@@ -953,7 +1259,18 @@
         _setStatusText() {
             if (!this._activeSession || !this._activeSession.ui) return;
             const depth = this._activeSession.chain.length;
-            const status = `Depth: ${depth} sailing${depth === 1 ? '' : 's'} - Side-by-side ${this._activeSession.allowSideBySide ? 'Allowed' : 'Disabled'}`;
+            let totalText = '';
+            try {
+                const totalRes = this._computeChainTotal();
+                if (totalRes && totalRes.hasAny && typeof App !== 'undefined' && App && App.Utils && typeof App.Utils.formatOfferValue === 'function') {
+                    totalText = ` • Total: ${App.Utils.formatOfferValue(totalRes.total)}`;
+                } else if (totalRes && totalRes.hasAny) {
+                    totalText = ` • Total: $${Math.round(totalRes.total).toLocaleString()}`;
+                } else {
+                    totalText = ' • Total: --';
+                }
+            } catch(e) { totalText = ''; }
+            const status = `Depth: ${depth} sailing${depth === 1 ? '' : 's'} - Side-by-side ${this._activeSession.allowSideBySide ? 'Allowed' : 'Disabled'}${totalText}`;
             this._activeSession.ui.statusSpan.textContent = status;
         },

@@ -981,6 +1298,14 @@
             const lastMeta = this._getMeta(lastId);
             if (!lastMeta) return [];
             const allowSideBySide = this._activeSession.allowSideBySide;
+            let drivingRangeHours = 0;
+            try {
+                if (window.App && App.SettingsStore && typeof App.SettingsStore.getB2BDrivingRangeHours === 'function') {
+                    drivingRangeHours = App.SettingsStore.getB2BDrivingRangeHours();
+                } else if (window.App && typeof App.B2BDrivingRangeHours !== 'undefined') {
+                    drivingRangeHours = App.B2BDrivingRangeHours;
+                }
+            } catch (e) { /* ignore */ }
             const usedOfferCodes = new Set(chain.map(id => {
                 const meta = this._getMeta(id);
                 return meta && meta.offerCode ? meta.offerCode : null;
@@ -996,11 +1321,38 @@
                     _dbg('Not linkable: isLinkable returned false', { from: lastMeta, to: candidateMeta });
                     return;
                 }
+                let isNearbyPort = false;
+                let nearbyLabel = '';
+                if (drivingRangeHours > 0) {
+                    const currentPort = (lastMeta.disembarkPort || '').toLowerCase();
+                    const nextPort = (candidateMeta.embarkPort || candidateMeta.disembarkPort || '').toLowerCase();
+                    if (currentPort && nextPort && currentPort !== nextPort) {
+                        // Check if nextPort is within driving range of currentPort
+                        try {
+                            if (typeof PortsTravelTimes !== 'undefined' && PortsTravelTimes && typeof PortsTravelTimes.getNearbyPorts === 'function') {
+                                const limitMinutes = drivingRangeHours * 60;
+                                const nearbyPorts = PortsTravelTimes.getNearbyPorts(currentPort, limitMinutes);
+                                const nextPortNormalized = PortsTravelTimes.normalizePort(nextPort);
+                                if (nearbyPorts.some(p => p.toLowerCase() === nextPortNormalized.toLowerCase())) {
+                                    isNearbyPort = true;
+                                    nearbyLabel = nextPort;
+                                }
+                            }
+                        } catch(e) { /* ignore and skip */ }
+                    }
+                }
                 const lag = diffDays(candidateMeta.startISO, lastMeta.endISO) || 0;
+                const isSideBySide = lastMeta.shipKey && candidateMeta.shipKey && lastMeta.shipKey !== candidateMeta.shipKey;
+                // Mark as region match if it's a side-by-side with a nearby port
+                const isRegionMatch = isSideBySide && isNearbyPort;
                 options.push({
                     rowId,
                     meta: candidateMeta,
-                    isSideBySide: lastMeta.shipKey && candidateMeta.shipKey && lastMeta.shipKey !== candidateMeta.shipKey,
+                    isSideBySide,
+                    isNearbyPort,
+                    nearbyLabel,
+                    isRegionMatch,
+                    regionLabel: isRegionMatch ? nearbyLabel : null,
                     lag
                 });
             });
@@ -1152,11 +1504,44 @@
                 _dbg('Not linkable: not same-day', { lag, currentMeta, nextMeta });
                 return false;
             }
+            let drivingRangeHours = 0;
+            try {
+                if (window.App && App.SettingsStore && typeof App.SettingsStore.getB2BDrivingRangeHours === 'function') {
+                    drivingRangeHours = App.SettingsStore.getB2BDrivingRangeHours();
+                } else if (window.App && typeof App.B2BDrivingRangeHours !== 'undefined') {
+                    drivingRangeHours = App.B2BDrivingRangeHours;
+                }
+            } catch (e) { /* ignore */ }
+
             const currentPort = (currentMeta.disembarkPort || '').toLowerCase();
             const nextPort = (nextMeta.embarkPort || nextMeta.disembarkPort || '').toLowerCase();
-            if (currentPort && nextPort && currentPort !== nextPort) {
-                _dbg('Not linkable: port mismatch', { currentPort, nextPort, currentMeta, nextMeta });
-                return false;
+
+            if (drivingRangeHours > 0) {
+                // Check if ports are within driving range
+                if (currentPort && nextPort && currentPort !== nextPort) {
+                    // Check if nextPort is within driving range of currentPort
+                    try {
+                        if (typeof PortsTravelTimes !== 'undefined' && PortsTravelTimes && typeof PortsTravelTimes.getNearbyPorts === 'function') {
+                            const limitMinutes = drivingRangeHours * 60;
+                            const nearbyPorts = PortsTravelTimes.getNearbyPorts(currentPort, limitMinutes);
+                            const nextPortNormalized = PortsTravelTimes.normalizePort(nextPort);
+                            const isNearby = nearbyPorts.some(p => p.toLowerCase() === nextPortNormalized.toLowerCase());
+                            if (!isNearby) {
+                                _dbg('Not linkable: port not within driving range', { currentPort, nextPort, drivingRangeHours, nearbyPorts });
+                                return false;
+                            }
+                        }
+                    } catch(e) {
+                        _dbg('Not linkable: driving range check failed', { currentPort, nextPort, error: e });
+                        return false;
+                    }
+                }
+            } else {
+                // Exact port match only
+                if (currentPort && nextPort && currentPort !== nextPort) {
+                    _dbg('Not linkable: exact port mismatch', { currentPort, nextPort, currentMeta, nextMeta });
+                    return false;
+                }
             }
             if (!allowSideBySide) {
                 if (currentMeta.shipKey && nextMeta.shipKey && currentMeta.shipKey !== nextMeta.shipKey) {
@@ -1175,6 +1560,17 @@
             const list = this._activeSession.ui.optionList;
             list.innerHTML = '';
             const options = this._computeNextOptions();
+            // Store option types for later retrieval when selecting
+            if (!this._activeSession.optionTypes) this._activeSession.optionTypes = {};
+            options.forEach(opt => {
+                if (opt.isRegionMatch) {
+                    this._activeSession.optionTypes[opt.rowId] = 'region-link';
+                } else if (opt.isSideBySide) {
+                    this._activeSession.optionTypes[opt.rowId] = 'side-by-side';
+                } else {
+                    this._activeSession.optionTypes[opt.rowId] = 'same-ship';
+                }
+            });
             if (!options.length) {
                 const empty = document.createElement('div');
                 empty.className = 'b2b-empty-state';
@@ -1194,6 +1590,15 @@
             let rows = null;
             let filterPredicate = null;
             let sessionUsedOfferCodes = null;
+            let drivingRangeHours = 0;
+            // Retrieve driving range hours setting
+            try {
+                if (window.App && App.SettingsStore && typeof App.SettingsStore.getB2BDrivingRangeHours === 'function') {
+                    drivingRangeHours = App.SettingsStore.getB2BDrivingRangeHours();
+                } else if (window.App && typeof App.B2BDrivingRangeHours !== 'undefined') {
+                    drivingRangeHours = App.B2BDrivingRangeHours;
+                }
+            } catch (e) { /* ignore */ }
             try {
                 if (window.B2BUtils && typeof B2BUtils.computeB2BDepth === 'function' && this._context && Array.isArray(this._context.rows)) {
                     // Use the authoritative rowMap values so indices align with rowIds
@@ -1232,7 +1637,15 @@
                             const candidateOffer = optMeta.offerCode || null;
                             const initialUsedOfferCodes = sessionUsedOfferCodes.slice();
                             if (candidateOffer) initialUsedOfferCodes.push(candidateOffer);
-                            const b2bOpts = { allowSideBySide: this._context.allowSideBySide, filterPredicate, initialUsedOfferCodes };
+                            let matchByRegion = false;
+                            try {
+                                if (window.App && App.SettingsStore && typeof App.SettingsStore.getB2BComputeByRegion === 'function') {
+                                    matchByRegion = !!App.SettingsStore.getB2BComputeByRegion();
+                                } else if (window.App && typeof App.B2BComputeByRegion !== 'undefined') {
+                                    matchByRegion = !!App.B2BComputeByRegion;
+                                }
+                            } catch (e) { /* ignore */ }
+                            const b2bOpts = { allowSideBySide: this._context.allowSideBySide, filterPredicate, initialUsedOfferCodes, drivingRangeHours };
                             // Tool always computes depths for options; ensure compute is forced
                             b2bOpts.force = true;
                             const depthsMap = B2BUtils.computeB2BDepth(rows, b2bOpts) || new Map();
@@ -1255,7 +1668,10 @@

             options.forEach(opt => {
                 const card = document.createElement('div');
-                card.className = 'b2b-option-card' + (opt.isSideBySide ? ' b2b-side-by-side' : '');
+                card.className = 'b2b-option-card'
+                    + (opt.isSideBySide ? ' b2b-side-by-side' : '')
+                    + (opt.isRegionMatch ? ' b2b-region-link' : '')
+                    + (!opt.isSideBySide && !opt.isRegionMatch ? ' b2b-same-ship' : '');
                 const metaBlock = document.createElement('div');
                 metaBlock.className = 'b2b-option-meta';
                 // Build header with ship name and badge on same line
@@ -1263,11 +1679,26 @@
                 headerDiv.className = 'b2b-option-card-header';
                 const shipTitle = document.createElement('strong');
                 shipTitle.textContent = opt.meta.shipName || opt.meta.shipCode || 'Ship';
+                const badges = document.createElement('div');
+                badges.className = 'b2b-option-badges';
                 const badge = document.createElement('div');
                 badge.className = 'badge';
-                badge.textContent = opt.isSideBySide ? 'Side-by-side' : 'Same ship';
+                if (opt.isRegionMatch) {
+                    badge.textContent = 'Different Port';
+                } else if (opt.isSideBySide) {
+                    badge.textContent = 'Side-by-side';
+                } else {
+                    badge.textContent = 'Same ship';
+                }
+                badges.appendChild(badge);
+                if (opt.isRegionMatch && opt.regionLabel) {
+                    const regionBadge = document.createElement('div');
+                    regionBadge.className = 'badge badge-region';
+                    regionBadge.textContent = opt.regionLabel;
+                    badges.appendChild(regionBadge);
+                }
                 headerDiv.appendChild(shipTitle);
-                headerDiv.appendChild(badge);
+                headerDiv.appendChild(badges);

                 // Compute route including intermediate regions from timeline
                 let routeLabel = '';
@@ -1363,16 +1794,28 @@
                     <span>${routeLabel}</span>
                     <span>${offerInfo}</span>
                 `;
-                const selectBtn = document.createElement('button');
+                // Build pricing section (will be added to card later, just before select button)
+                let pricingElement = null;
+                try {
+                    pricingElement = this._buildPricingSection(opt.meta, opt.rowId, {
+                        selectable: true,
+                        useButton: false,
+                        onSelectCategory: () => {
+                            try { this._selectOption(opt.rowId); } catch(e) { /* ignore */ }
+                        }
+                    });
+                } catch(e) { /* ignore pricing build errors */ }
+                const selectBtn = document.createElement('div');
                 selectBtn.className = 'b2b-option-select';
-                selectBtn.type = 'button';
+                selectBtn.setAttribute('role', 'button');
+                selectBtn.setAttribute('tabindex', '0');
                 selectBtn.textContent = 'Add to chain';
                 // Depth pill (render inside the Add button on the right)
                 try {
                     // Prefer immediate next-candidate count so we show 'No more' when there are none,
                     // even if further descendants exist.
                     const immediateCount = this._computeImmediateCount(opt.rowId, opt.rowId);
-                    const descendantDepth = (typeof opt.depth === 'number') ? opt.depth : (opt.meta && opt.meta.sailing && typeof opt.meta.sailing.__b2bDepth === 'number' ? opt.meta.sailing.__b2bDepth : 1);
+                    let descendantDepth = (typeof opt.depth === 'number') ? opt.depth : (opt.meta && opt.meta.sailing && typeof opt.meta.sailing.__b2bDepth === 'number' ? opt.meta.sailing.__b2bDepth : 1);
                     try {
                         const ocode = opt.meta && opt.meta.offerCode ? opt.meta.offerCode : safeOfferCode(opt.entry || {});
                         try {
@@ -1479,9 +1922,22 @@
                     // Attach direct handler; tool precomputes depths so no on-demand logic required here
                     try {
                         selectBtn.addEventListener('click', () => this._selectOption(opt.rowId), false);
+                        selectBtn.addEventListener('keydown', (ev) => {
+                            if (ev.key === 'Enter' || ev.key === ' ') {
+                                ev.preventDefault();
+                                this._selectOption(opt.rowId);
+                            }
+                        }, false);
+                        selectBtn.addEventListener('mousedown', (ev) => {
+                            // Prevent focus-induced scroll jumps on some browsers
+                            ev.preventDefault();
+                        }, false);
                     } catch(e) { /* ignore */ }
                 } catch (e) { /* ignore depth badge errors */ }
                 card.appendChild(metaBlock);
+                if (pricingElement) {
+                    card.appendChild(pricingElement);
+                }
                 card.appendChild(selectBtn);
                 list.appendChild(card);
             });
@@ -1510,6 +1966,12 @@
             this._scheduleWithSpinner(() => {
                 try { this._logLayoutState && this._logLayoutState(); } catch(e){}
                 this._activeSession.chain.push(rowId);
+                // Store the card type for styling selected chain cards
+                if (!this._activeSession.chainTypes) this._activeSession.chainTypes = {};
+                const optionTypes = this._activeSession.optionTypes || {};
+                if (optionTypes[rowId]) {
+                    this._activeSession.chainTypes[rowId] = optionTypes[rowId];
+                }
                 this._renderChain();
                 try { this._scrollChainToBottom(); } catch(e) {}
                 this._renderOptions();